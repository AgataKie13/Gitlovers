---
title: "Projekt Analiza Danych"
author: "A. Kierznikowicz, J. Dobosz, P. Cebulska"
date: "2024-11-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE, include = FALSE)
```

## 1. Wczytanie danych

```{r}
dane <- read.csv("Hipoteczny.csv")
```

## 2. Porządkowanie danych

W pierwszej części projektu analizujemy dane źródłowe pod kątem wystąpienia **braków danych**.

## a) Wstępne rozeznanie

```{r}
head(dane)
```

## b) Sprawdzanie braków danych

```{r}
sum(is.na(dane))
```

## c) Sprawdzanie czy są puste komórki

```{r}
sum(dane == "", na.rm = TRUE)
```

## d) zsumowanie pustych komórek i komórek NA

```{r}
sum(dane == "" | is.na(dane), na.rm = TRUE)
```

Z powyższej analizy wynika, że wśród danych źródłowych znjaduje się **40** wartości oznaczonych jako NA oraz **44** zmienne puste. W związu z tym należy przekodować zmienne tak, aby w miejsce pustych komórek pojawiły się wartości NA.

## 3. Przekodowanie zmiennych

Na początek zmienne kategoryczne zostają przekodowane na zmienne numeryczne, aby możliwe było zbadanie koralecji pomiędzy poszczególnymi zmiennymi oraz aby zapobiec pojawianiu się pustych komórek.

```{r}
dane2 <- dane
dane2$Gender <- ifelse(dane2$Gender == "Female", 0,
                       ifelse(dane2$Gender == "Male", 1, NA))

dane2$Married <- ifelse(dane2$Married == "Yes", 1, 
                              ifelse(dane2$Married == "No", 0, NA))

dane2$Self_Employed <- ifelse(dane2$Self_Employed == "Yes", 1, 
                                  ifelse(dane2$Self_Employed == "No", 0, NA))


dane2$Education <- ifelse(dane2$Education == "Graduate", 1, 
                              ifelse(dane2$Education == "Not Graduate", 0, NA))


dane2$Property_Area <- ifelse(dane2$Property_Area == "Rural", 1, 
                                ifelse(dane2$Property_Area == "Semiurban", 2, 
                                  ifelse(dane2$Property_Area == "Urban", 3, NA)))
                            


dane2$Dependents <- ifelse(dane2$Dependents == "3+", 3, 
                                  ifelse(dane2$Dependents == "2", 2, 
                                         ifelse(dane2$Dependents == "1", 1,
                                                ifelse(dane2$Dependents == "0", 0, NA))))
                           
dane2 <- dane2[,-1]
```

**opis przekształceń poszczególnych zmiennych kategorycznych do postaci numerycznej**

**Gender:** Zmienna Gender zawiera informacje o płci, "Male" jest kodowana jako 1, a "Female" 0.

**Married:** Zmienna Married jest przekodowywana, aby 1 oznaczało "Yes",a 0 "No".

**Self_Employed:** Zmienna Self_Employed jest przekodowywana na 1 dla odpowiedzi "Yes", a 0 dla "No".

**Education:** Wartości "Graduate" są kodowane jako 1, a "Not Graduate" jako 0

**Property_Area:** Zmienna Property_Area zawiera trzy kategorie: "Rural", "Semiurban", "Urban". Zostały im przypisane kolejno liczby: 1, 2 i 3.

**Dependents:** Zmienna Dependents zawiera liczbę osób na utrzymaniu, wartość "3+" jest zamieniana na 3, a pozostałe wartości są przekodowane na liczby.

## a) Następnie sprawdzamy jak wyglądają zmienne po przekodowaniu.

```{r}
head(dane2)
```

## b) Sprawdzanie czy są puste komórki

```{r}
sum(dane2 == "", na.rm = TRUE)
```

W wyniku przekodowania zmiennych zniwelowane zostały puste komórki, które przyjęły teraz postać NA.

## c) Sprawdzanie braków danych

```{r}
sum(is.na(dane2))
```

Ostatecznie w danych znajdują się **84** braki danych oznaczone jako NA.

## d) Zmieniamy zmienne po przekodowaniu na numeryczne.

```{r}
dane2 <- dane2[, sapply(dane2, is.numeric)]
```

## 4. Analiza braków danych

## a) Macierz korelacji poszczególnych zmiennych

Następnie tworzymy macierz korelacji wszystkich zmiennych.
```{r}
install.packages("rstatix")
library(rstatix)
korelacja <- cor_mat(dane2)

install.packages("ggcorrplot")
library(ggcorrplot)
ggcorrplot(cor(dane2))

```

Macierz korelacji przedstawia zależności pomiędzy wszystkimi zmiennymi, umożliwiając wstępną ocenę, które zmienne i w jakim stopniu są ze sobą skorelowane.

## b) Graficzna analiza braków danych

Tworzymy macierz korelacji pomiędzy brakującymi zmiennymi, aby ocenić czy występują jakieś zależności w brakach danych.

```{r echo=FALSE}

install.packages("finalfit")
install.packages("naniar")
library(mice)
dane2_wykres <- dane2 
names(dane2_wykres) <- c("G","M","D","E","SE","A","C","LA","LAT","CH","PA")
md.pattern(dane2_wykres)
library(naniar)
gg_miss_fct(dane2, Credit_History)
gg_miss_upset(dane2)
vis_miss(dane2, cluster=TRUE, sort_miss=TRUE)
```

## 5. WNIOSKI

Pierwszy z efektów analizy to **macierz wzorców braków danych**, która przedstawia unikalne wzorce braków danych dla poszczególnych zmiennych. Komórki z brakami są zaznaczone w tabeli na różowo, co pozwala zrozumieć, które zmienne i jak często mają braki. Pierwszy wiersz (289 obserwacji) nie ma żadnych braków danych. Oznacza to, że większość danych jest kompletna. Natomiast W pozostałych wierszach widzimy różne wzorce braków. Na przykład w drugim wierszu 25 obserwacji ma braki w zmiennej CH. Z kolei zmienna CH ma 29 braków.

Drugi wynikiem jest **wykres słupkowy braków danych względem kategorii**, który przedstawia procent braków danych w każdej kolumnie. Następnie sporządzony został **diagram UpSet dla brakujących danych**, który podobnie jak macierz, przedstawia ilość braków w zależności od kolumny.

Na koniec zbudowano **mapę cieni**, która przedstawia procentowy udział braków danych w całości analizowanych danych. W analizowanym przypadku braki danych stanowią 2,1% zmiennych, z czego największy udział mają braki w kolumnie Credit_History (8%), a najmniejszy - LoanAmount (1%).

## Test statystyczny braków danych

```{r}
mcar_test(dane2)
```

Hipoteza zerowa testu: Braki danych są MCAR (całkowicie losowe). Hipoteza alternatywna testu: Braki danych nie są MCAR.

*Wartość p (0.9918873) jest znacznie większa niż próg istotności (0.05)*, więc nie ma podstaw do odrzucenia hipotezy zerowej. Oznacza to, że braki w analizowanych danych są całkowicie losowe i nie zależą od wartości innych zmiennych ani samych brakujących danych. Co więcej, istnienie *12 wzorców braków danych* sugeruje, że różne obserwacje mają różne kombinacje braków.

Ponadto obserwowany niski poziom korelacji pomiędzy zmiennymi oraz analiza powyższych wykresów wskazuje na to, że braki danych należy skategoryzować jako MCAR (Całkowicie losowe braki danych).

## 6. Analiza odchyleń

## a) Obserwacje odstające - jednowymiarowe - Boxplot

```{r}
boxplot(dane2)

par(mfrow = c(2, 2), las = 2)
boxplot(dane2$ApplicantIncome, dane2$CoapplicantIncome, names = c("AppIncome", "CoappIncome"))
boxplot(dane2$Loan_Amount_Term, dane2$LoanAmount, names = c("LoanAmountT", "LoanAmount"))
boxplot(dane2$Gender, dane2$Education, dane2$Credit_History, dane2$Self_Employed, names=c("Płeć", "W", "HK", "SZ"))
boxplot(dane2$Married, dane2$Dependents, dane2$Property_Area, names=c("SC", "LOU", "Property"))  #bez odchyleń

par(mfrow = c(1, 1))
plot.new() 
legend("topleft",      
       legend = c("AppIncome = Dochód wnioskodawcy", "CoappIncome=Dochód współwnioskodawcy",
                  "W= Wykształcenie", "HK=Historia Kredytowa", "SZ=Samozatrudnienie",
                  "SC=Stan cywilny", "LOU=l. osób na utrzymaniu"),
       cex = 0.9)     
```

```{r}
outliers <- boxplot.stats(dane2$Gender)$out
outliers_idx <- which(dane2$Gender %in% outliers)
dane2[outliers_idx,]
dane2[outliers_idx,1:4] <- dane2[outliers_idx,1:4]/10
summary(dane2)
```

## b) Obserwacje odstające - wielowymiarowe - Scatterplot

```{r}
library(GGally)
ggcorr(dane2)

x <- dane2$ApplicantIncome
y <- dane2$CoapplicantIncome
plot(x, y, xlab="AppIncome", ylab="CoappIncome")

a <- dane2$Married
b <- dane2$Gender
plot(a, b, xlab="Married", ylab="Gender")

c <- dane2$Education
d <- dane2$CoapplicantIncome
plot(c, d, xlab="Education", ylab="CoappIncome")

e <- dane2$Self_Employed
f <- dane2$Education
plot(e, f, xlab="self_employed", ylab="education")

g <- dane2$Self_Employed
h <- dane2$Property_Area
plot(g, h, xlab="self_employed", ylab="property")

i <- dane2$CoapplicantIncome
j <- dane2$Property_Area
plot(i, j, xlab="CoappIncome", ylab="property")
```

## c) Metoda kwantyl-kwantyl

Stworzono wykresy typu Q-Q dla zmiennych, dla których zidentyfikowano wartości odchylające się podczas analizy wykresami pudełkowymi

```{r}
qqnorm(dane2$ApplicantIncome, pch = 1, frame = FALSE, main = "Dochód wnioskodawcy")
qqline(dane2$ApplicantIncome, col = "steelblue", lwd = 2)

qqnorm(dane2$CoapplicantIncome, pch = 1, frame = FALSE, main = "Dochód współwnioskodawcy")
qqline(dane2$CoapplicantIncome, col = "steelblue", lwd = 2)
        
qqnorm(dane2$Loan_Amount_Term, pch = 1, frame = FALSE, main = "Loan_Amount_Term")
qqline(dane2$Loan_Amount_Term, col = "steelblue", lwd = 2)
        
qqnorm(dane2$LoanAmount, pch = 1, frame = FALSE, main = "Kwota kredytu")
qqline(dane2$LoanAmount, col = "steelblue", lwd = 2)

qqnorm(dane2$Gender, pch=1, frame=FALSE, main= "Płeć")
qqline(dane2$Gender, col="steelblue", lwd=2)

qqnorm(dane2$Education, pch=1, frame=FALSE, main = "Wykształcenie")
qqline(dane2$Education, col="steelblue", lwd=2)

qqnorm(dane2$Credit_History, pch=1, frame=FALSE, main = "Historia kredytu")
qqline(dane2$Credit_History, col="steelblue", lwd=2)

qqnorm(dane2$Self_Employed, pch=1, frame=FALSE, main = "Samozatrudnienie")
qqline(dane2$Self_Employed, col="steelblue", lwd=2)
```

## d) Odchylenia Cook'a

```{r}
library(broom)
fit = lm(LoanAmount ~ Married,data=dane2)
cooks.distance(fit)
plot(fit,which=4)

fit1 = lm(LoanAmount ~ Gender,data=dane2)
cooks.distance(fit1)
plot(fit1,which=4)

fit2 = lm(LoanAmount ~ Education,data=dane2)
cooks.distance(fit2)
plot(fit2,which=4)

fit3 = lm(LoanAmount ~ ApplicantIncome,data=dane2)
cooks.distance(fit3)
plot(fit3,which=4)

fit4 = lm(LoanAmount ~ Loan_Amount_Term,data=dane2)
cooks.distance(fit4)
plot(fit4,which=4)
```

## 7. Imputacja brakujących danych
**?? ŚREDNIA, MEDIANA ??**
## a) Zastępowanie brakujących danych dominantą

*1. Funkcja licząca dominantę*

```{r}
dominanta <- function(x) {
  # Sprawdza, czy kolumna jest numeryczna czy kategoryczna
  if (is.numeric(x)) {
    return(names(sort(table(x), decreasing = TRUE)[1]))
  } else if (is.factor(x) || is.character(x)) {
    return(names(sort(table(x), decreasing = TRUE)[1]))
  }
}
library(tidyr)
```

*2. Zastosowanie funkcji na wszystkich kolumnach*

```{r}
daned <- dane2
dominanty_zmiennych <- sapply(daned, dominanta)
dominanty <- data.frame(dominanty_zmiennych)
dominanty <- t(dominanty)
dominanty <- as.data.frame(lapply(dominanty, as.factor))
colnames(dominanty) <- colnames(dane2)
print(dominanty)
```

*3. Zastąpienie braków danych dominantą*

```{r}
dominanty <- lapply(dominanty, as.numeric)
for (col in colnames(daned)) {
  daned[[col]][is.na(daned[[col]])] <- dominanty [[col]]
}
```

*4. Sprawdzenie, czy wszystkie braki danych zostały zastąpione*

```{r}
library(mice)
md.pattern(daned)
```

## b) Imputacja brakujących danych metodą KNN - K-najbliższych sąsiadów

```{r}
daneKNN <- dane2
library(VIM)

dane_KNN <- kNN(daneKNN, k = 5, imp_var = FALSE)
```

Brakujące dane zostały uzupełnione za pomocą 5 najbliższych sąsiednich wartości. (k = 5)
Ponowne sprawdzenie czy istnieją braki po imputacji.

```{r}
sum(is.na(dane_KNN))
```

**?DRZEWA LOSOWE?-RPART**

## c) Wielowymiarowe wypełnianie braków danych przez równania łańcuchowe

Do imputacji braków w danych użyto pakietu **mice** (Multivariate Imputation by Chained Equations), stosując metodę **pmm** (Predictive Mean Matching), która wypełniała braki na podstawie podobnych obserwacji z danych.

```{r}
library(mice)
danem <- dane2
Gender_imputed <- mice(danem[, c("Gender", "Married", "Dependents", "Education", "Self_Employed", 
                                "ApplicantIncome", "CoapplicantIncome", "LoanAmount", 
                                "Loan_Amount_Term", "Credit_History", "Property_Area")], 
                       m = 5, method = "pmm")

dane2$Gender <- complete(Gender_imputed)$Gender
```

Zimputowane zostały brakujące obserwacje w zmiennej **Gender**, a następnie uzupełniono brakujące wartości w zbiorze danych.

Proces ten został powtórzony dla pozostałych zmiennych

**zmienna Dependents**

```{r}
Dependents_imputed <- mice(danem[, c("Dependents", "Gender", "Married", "Education", "Self_Employed", 
                                    "ApplicantIncome", "CoapplicantIncome", "LoanAmount", 
                                    "Loan_Amount_Term", "Credit_History", "Property_Area")], 
                           m = 5, method = "pmm")

dane2$Dependents <- complete(Dependents_imputed)$Dependents
```

**zmienna Self_Employed**

```{r}
Self_Employed_imputed <- mice(danem[, c("Self_Employed", "Gender", "Married", "Dependents", 
                                       "Education", "ApplicantIncome", "CoapplicantIncome", 
                                       "LoanAmount", "Loan_Amount_Term", "Credit_History", "Property_Area")], 
                              m = 5, method = "pmm")

dane2$Self_Employed <- complete(Self_Employed_imputed)$Self_Employed
```

**zmienna LoanAmount**

```{r}
LoanAmount_imputed <- mice(danem[, c("LoanAmount", "Gender", "Married", "Dependents", 
                                    "Education", "Self_Employed", "ApplicantIncome", 
                                    "CoapplicantIncome", "Loan_Amount_Term", "Credit_History", "Property_Area")], 
                           m = 5, method = "pmm")

dane2$LoanAmount <- complete(LoanAmount_imputed)$LoanAmount
```

**zmienna Loan_Amount_Term**

```{r}
Loan_Amount_Term_imputed <- mice(danem[, c("Loan_Amount_Term", "Gender", "Married", "Dependents", 
                                          "Education", "Self_Employed", "ApplicantIncome", 
                                          "CoapplicantIncome", "LoanAmount", "Credit_History", "Property_Area")], 
                                 m = 5, method = "pmm")

dane2$Loan_Amount_Term <- complete(Loan_Amount_Term_imputed)$Loan_Amount_Term
```

**zmienna Credit_History**

```{r}
Credit_History_imputed <- mice(danem[, c("Credit_History", "Gender", "Married", "Dependents", 
                                        "Education", "Self_Employed", "ApplicantIncome", 
                                        "CoapplicantIncome", "LoanAmount", "Loan_Amount_Term", "Property_Area")], 
                               m = 5, method = "pmm")

dane2$Credit_History <- complete(Credit_History_imputed)$Credit_History
```

Proces został wykonany dla każdej zmiennej z brakami (Gender, Dependents, Self_Employed, LoanAmount, Loan_Amount_Term, Credit_History) i polegał na imputacji tych braków w konkretnej zmiennej na podstawie podobnych obserwacji z danych.

Sprawdzenie czy wszystkie braki zostały uzupełnione.

```{r}
sum(is.na(danem))
```

## d) Imputacja brakujących danych metodą hot-deck

```{r}
library(hot.deck)

dane_hd <- hot.deck(dane2, m = 1, method = "best.cell", cutoff = 10, sdCutoff = 1,
         optimizeSD = FALSE, optimStep = 0.1, optimStop = 5, weightedAffinity = FALSE,
         impContinuous = "HD")

dane_hd <- dane_hd[["data"]][[1]]
```

...... Jeszcze raz sprawdzam, czy zostały zapełnione wszystkie komórki z NA

```{r}
install.packages("finalfit")
library(mice)
md.pattern(dane_hd)
```

**PORÓWNANIE STATYSTYK PRZED I PO UŻYCIU RÓŻNYCH METOD IMPUTACJI DANYCH**

```{r}
srednia <- (sapply(dane2,mean, na.rm = TRUE))
mediana <- (sapply(dane2,median, na.rm = TRUE))
minimum <- (sapply(dane2,min, na.rm = TRUE))
maximum <- (sapply(dane2,max, na.rm = TRUE))
kwantyl1 <- (sapply(dane2,quantile, na.rm = TRUE, probs = 0.25))
kwantyl3 <- (sapply(dane2,quantile, na.rm = TRUE, probs = 0.75))


sredniahd <- (sapply(dane_hd,mean, na.rm = TRUE))
medianahd <- (sapply(dane_hd,median, na.rm = TRUE))
minimumhd <- (sapply(dane_hd,min, na.rm = TRUE))
maximumhd <- (sapply(dane_hd,max, na.rm = TRUE))
kwantyl1hd <- (sapply(dane_hd,quantile, na.rm = TRUE, probs = 0.25))
kwantyl3hd <- (sapply(dane_hd,quantile, na.rm = TRUE, probs = 0.75))


sredniaKNN <- (sapply(dane_KNN,mean, na.rm = TRUE))
medianaKNN <- (sapply(dane_KNN,median, na.rm = TRUE))
minimumKNN <- (sapply(dane_KNN,min, na.rm = TRUE))
maximumKNN <- (sapply(dane_KNN,max, na.rm = TRUE))
kwantyl1KNN <- (sapply(dane_KNN,quantile, na.rm = TRUE, probs = 0.25))
kwantyl3KNN <- (sapply(dane_KNN,quantile, na.rm = TRUE, probs = 0.75))


sredniam <- (sapply(danem,mean, na.rm = TRUE))
medianam <- (sapply(danem,median, na.rm = TRUE))
minimumm <- (sapply(danem,min, na.rm = TRUE))
maximumm <- (sapply(danem,max, na.rm = TRUE))
kwantyl1m <- (sapply(danem,quantile, na.rm = TRUE, probs = 0.25))
kwantyl3m <- (sapply(danem,quantile, na.rm = TRUE, probs = 0.75))


sredniad <- (sapply(daned,mean, na.rm = TRUE))
medianad <- (sapply(daned,median, na.rm = TRUE))
minimumd <- (sapply(daned,min, na.rm = TRUE))
maximumd <- (sapply(daned,max, na.rm = TRUE))
kwantyl1d <- (sapply(daned,quantile, na.rm = TRUE, probs = 0.25))
kwantyl3d <- (sapply(daned,quantile, na.rm = TRUE, probs = 0.75))


srednia_all <- data.frame(srednia, sredniad, sredniahd, sredniaKNN, sredniam)
srednia_all <- t(srednia_all)
mediana_all <- data.frame(mediana, medianad, medianahd, medianaKNN, medianam)
mediana_all <- t(mediana_all)
minimum_all <- data.frame(minimum, minimumd, minimumhd, minimumKNN, minimumm)
minimum_all <- t(minimum_all)
maximum_all <- data.frame(maximum, maximumd, maximumhd, maximumKNN, maximumm)
maximum_all <- t(maximum_all)
kwantyl1_all <- data.frame(kwantyl1, kwantyl1d, kwantyl1hd, kwantyl1KNN, kwantyl1m)
kwantyl1_all <- t(kwantyl1_all)
kwantyl3_all <- data.frame(kwantyl3, kwantyl3d, kwantyl3hd, kwantyl3KNN, kwantyl3m)
kwantyl3_all <- t(kwantyl3_all)
statystyki_all <- rbind(srednia_all, mediana_all, minimum_all, maximum_all, kwantyl1_all, kwantyl3_all)
```

